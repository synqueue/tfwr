# TFWR MCP — Tool Reference

Two integration layers are available. **File-based** tools work any time the game has been launched
at least once. **Live** tools (prefixed `live_`) require the **MCPBridge BepInEx mod** to be
installed and the game to be running.

---

## Requirements

### File-based layer
- Game launched at least once (so save folders exist on disk).
- Save directory auto-detected from `%LOCALAPPDATA%\..\LocalLow\TheFarmerWasReplaced\`.
- Override with the `TFWR_DATA_PATH` environment variable.

### Live layer (mod)
- MCPBridge mod installed under BepInEx in the game folder.
- Game is running (mod starts an HTTP server on `localhost:7070`).
- **File Watcher** enabled in game Options, **Autosave disabled** (required for
  `live_write_run_wait` to push code into the game automatically).
- Override mod URL with the `TFWR_MOD_URL` environment variable.

---

## Recommended session flow

```
live_snapshot()          ← what do I have / what's running?
live_farm_grid()         ← what's on the farm right now?
live_shop()              ← what can I buy right now?
get_builtins_reference() ← what functions are available at this unlock level?

loop:
  live_write_run_wait()  ← write script + run + wait for it to finish
  live_shop()            ← spend any new resources immediately
  live_buy_upgrade()     ← purchase upgrades as they become affordable
```

---

## File-based tools

### `list_saves()`
Lists every save slot directory found on disk.

**Returns:** `list[str]` — e.g. `["Save0", "Save1"]`.
Returns a single-element list with a help message if no saves exist yet.

---

### `list_scripts(save_name="Save0")`
Lists all player-editable `.py` script files in a save slot.
`__builtins__.py` is excluded (it is the game's built-in stubs, not a user script).

**Args:**
- `save_name` — save slot directory name (default: `Save0`).

**Returns:** `list[str]` — script names without the `.py` extension, sorted alphabetically.

---

### `read_script(script_name, save_name="Save0")`
Reads the source code of a script file from disk.

**Args:**
- `script_name` — name without `.py` (e.g. `"main"`).
- `save_name` — save slot (default: `Save0`).

**Returns:** `str` — full UTF-8 source code of the script.
Raises if the script does not exist and lists available scripts.

---

### `write_script(script_name, content, save_name="Save0")`
Writes (creates or overwrites) a script file on disk.

If **File Watcher** is enabled in Options, the game reloads the file automatically.
Otherwise the player must press **Run** manually.

Prefer `live_write_run_wait()` when the mod is available — it writes, runs, and
waits for results in a single call.

**Args:**
- `script_name` — name without `.py`.
- `content` — complete source code to write.
- `save_name` — save slot (default: `Save0`).

**Returns:** `str` — confirmation message with byte count.

---

### `read_game_state(save_name="Save0")`
Reads inventory and unlocks from the save file (`save.json`) on disk.

This is a static snapshot — it only reflects what was last saved to disk,
not the live in-game state. Use `live_state()` or `live_snapshot()` for
up-to-the-moment data.

**Args:**
- `save_name` — save slot (default: `Save0`).

**Returns:**
```json
{
  "unlocks": ["loops", "variables", "expand_3", ...],
  "items":   { "Hay": 412.0, "Wood": 55.0 },
  "version": 14
}
```

---

### `get_builtins_reference(save_name="Save0")`
Returns the full `__builtins__.py` stubs file generated by the game.

This is the **authoritative scripting reference**: every built-in function,
entity constant, item constant, ground type, unlock name, hat name, direction,
and leaderboard is documented here. Always read this before writing scripts
for an unfamiliar unlock level.

**Args:**
- `save_name` — save slot (default: `Save0`).

**Returns:** `str` — raw content of `__builtins__.py`.

---

### `get_game_info()`
Returns a human-readable overview of how the scripting system works:
coordinate system, File Watcher setup, key unlock names, and the save path.

**Returns:** `str` — Markdown text.

---

## Live tools — basic

All live tools fail with a `RuntimeError` if the MCPBridge mod is not reachable.

---

### `live_status()`
Lightweight poll: is the game executing a script right now?

**Returns:**
```json
{
  "isExecuting":  false,
  "isSimulating": false,
  "worldSize":    5,
  "timeSec":      183.421
}
```
- `isExecuting` — a script is currently running.
- `isSimulating` — a leaderboard run is in progress.
- `worldSize` — current farm side length in tiles (square grid).
- `timeSec` — in-game elapsed time in seconds since last run started.

---

### `live_state()`
Full live game state directly from the running process.
More up-to-date than `read_game_state()` which reads the save file.

**Returns:**
```json
{
  "unlocks":      { "loops": 1, "variables": 1, "expand": 3, ... },
  "items":        { "Hay": 412.0, "Wood": 55.0 },
  "worldSize":    5,
  "timeSec":      183.421,
  "isExecuting":  false,
  "isSimulating": false
}
```
- `unlocks` — map of unlock name → level (multi-level upgrades show level > 1).
- `items` — current inventory, item name → quantity.

---

### `live_output()`
Returns all `print()` output accumulated since the last `live_clear_output()` call
(or since the last `live_run()` / `live_write_run_wait()` which clears it automatically).
Also contains runtime warnings and error messages.

**Returns:**
```json
{ "output": "harvested 3 hay\nwarning: failed to harvest\n..." }
```

---

### `live_clear_output()`
Clears the script output log inside the game.

**Returns:** `{"ok": true, "message": "output cleared"}`

---

### `live_scripts()`
Lists all code windows currently open inside the game UI,
and whether each one is currently executing.

**Returns:**
```json
{
  "scripts": [
    { "name": "main",   "isExecuting": true  },
    { "name": "helper", "isExecuting": false }
  ]
}
```

> **Note:** `live_run()` and `live_write_run_wait()` require the target script
> to have an open code window in the game. Use this tool to verify.

---

### `live_run(script_name="main")`
Starts executing a named script that is already open in the game.

Fails immediately if:
- The script is not open as a code window in-game (open it manually once).
- Another script is already executing (call `live_stop()` first, or use
  `live_write_run_wait()` which handles this automatically).
- The script has a parse error (check the in-game error panel).

This tool fires and returns immediately — it does **not** wait for the script to
finish. Use `live_run_and_wait()` or `live_write_run_wait()` to block until done.

**Args:**
- `script_name` — name of the script to run (default: `"main"`).

**Returns:** `{"ok": true/false, "message"/"error": str}`

---

### `live_stop()`
Stops the currently executing script immediately.

**Returns:** `{"ok": true, "message": "stopped"}`

---

### `live_step()`
Advances execution by one step when the game is in step-by-step (breakpoint) mode.

**Returns:** `{"ok": true, "message": "stepped"}`

---

## Live tools — game loop

These tools are the primary interface for autonomous play. Use them instead of
the basic tools above whenever possible.

---

### `live_snapshot()`
Gets everything useful in one call: full state **plus** current output.
Equivalent to `live_state()` + `live_output()` merged into one response.

Use this at the **start of every session** and after any action that changes
game state.

**Returns:**
```json
{
  "unlocks":      { "loops": 1, ... },
  "items":        { "Hay": 412.0 },
  "worldSize":    5,
  "timeSec":      183.4,
  "isExecuting":  false,
  "isSimulating": false,
  "output":       "harvested 3 hay\n..."
}
```

---

### `live_farm_grid()`
Returns the complete layout of the farm — every tile's entity, ground type,
grow progress, and water level — plus all drone positions.

Use this before writing any script so you know what's actually on the farm
(what is planted, what is grown and ready to harvest, where bare soil is, etc.).

**Returns:**
```json
{
  "world_size": { "x": 5, "y": 5 },
  "drones": [
    { "id": 0, "x": 2, "y": 3 }
  ],
  "cells": [
    {
      "x": 0, "y": 0,
      "entity":      "wheat",
      "grown_pct":   0.847,
      "harvestable": false,
      "ground":      "soil",
      "water":       0.312
    },
    {
      "x": 1, "y": 0,
      "entity":      "wheat",
      "grown_pct":   1.0,
      "harvestable": true,
      "ground":      "soil",
      "water":       0.0
    },
    {
      "x": 2, "y": 0,
      "entity": null,
      "ground": "grassland",
      "water":  0.0
    }
  ]
}
```

**Field notes:**
- `entity` — internal object name (e.g. `"wheat"`, `"grass"`, `"tree"`, `"rock"`), or `null` for empty cells.
- `grown_pct` — `0.0` (just planted) → `1.0` (fully grown). Only present for growable entities.
- `harvestable` — `true` when the entity can be harvested right now. Only present for growable entities.
- `ground` — tile ground type (e.g. `"grassland"`, `"soil"`).
- `water` — water level on the tile, `0.0`–`1.0`. Watered soil speeds crop growth.
- `drones` — one entry per drone; `id` matches the drone index used in megafarm scripts.

---

### `live_shop()`
Lists every upgrade that is purchasable right now: parent prerequisites met,
not yet at maximum level.

Call this after **every** script run — items collected may have made new
upgrades affordable.

**Returns:** `list` of upgrade objects:
```json
[
  {
    "name":       "loops",
    "level":      0,
    "max_level":  1,
    "can_afford": true,
    "cost":       { "Hay": 100 },
    "parent":     "variables",
    "descr":      "Unlocks while loops"
  },
  {
    "name":       "speed",
    "level":      2,
    "max_level":  10,
    "can_afford": false,
    "cost":       { "Hay": 800, "Wood": 200 }
  }
]
```

**Field notes:**
- `name` — pass this directly to `live_buy_upgrade()`.
- `level` — current level. `0` = never purchased. For multi-level upgrades (speed, expand, etc.) this is how many times it has been bought.
- `max_level` — purchasing at `level == max_level - 1` maxes it out.
- `can_afford` — `true` if current inventory has enough of every required item.
- `cost` — items needed for the **next** level. Empty `{}` means free.
- `parent` — the upgrade that must be purchased first (already guaranteed to be owned, since only reachable upgrades are listed).

---

### `live_buy_upgrade(unlock_name)`
Purchases the next level of an upgrade, deducting required items from inventory.

Always call `live_shop()` first to confirm the upgrade is available and
`can_afford` is `true`.

**Args:**
- `unlock_name` — upgrade identifier string from `live_shop()`, e.g. `"loops"`, `"speed"`, `"expand"`.

**Returns:**
```json
{ "ok": true,  "message": "Purchased 'loops'" }
{ "ok": false, "error":   "Cannot purchase 'loops': insufficient items, ..." }
```

Fails if: already at max level, parent unlock not met, insufficient items,
or a leaderboard simulation is currently running.

---

### `live_run_and_wait(script_name="main", timeout_sec=120)`
Starts a script that is already open in the game and **blocks until it finishes**,
then returns output and state together.

Use this when you have already written the script to disk (e.g. via `write_script()`)
and just need to run it. Prefer `live_write_run_wait()` when you also need to
update the code.

**Args:**
- `script_name` — script to run (default: `"main"`).
- `timeout_sec` — maximum wall-clock seconds to wait (default: `120`). Returns early with `timed_out: true` if exceeded.

**Returns:**
```json
{
  "output":      "harvested 5 hay\n",
  "state":       { "unlocks": {...}, "items": {...}, ... },
  "elapsed_sec": 4.2,
  "timed_out":   false
}
```
- `output` — everything printed by the script plus any warnings/errors.
- `state` — full `live_state()` snapshot captured the moment execution ended.
- `elapsed_sec` — real-world seconds the script took to finish.
- `timed_out` — `true` if the script was still running when `timeout_sec` was reached (state and output are still returned for whatever ran so far).

If the script fails to start (parse error, script not open, already executing),
an `"error"` key is returned instead and `output`/`state` are empty.

---

### `live_write_run_wait(script_name, content, save_name="Save0", timeout_sec=120)`
**The primary game-loop tool.** Writes a script to disk, starts it in the game,
waits for it to finish, and returns the results — all in one call.

Internally it:
1. Writes `content` to `<saves>/<save_name>/<script_name>.py`.
2. Waits 0.5 s for **File Watcher** to reload the file into the game's code window.
3. Calls `live_stop()` to clear any in-progress execution.
4. Calls `live_run()` to start the newly loaded script.
5. Polls `live_status()` every second until `isExecuting` is `false` or timeout.
6. Collects and returns `live_output()` + `live_state()`.

**Requirements:**
- MCPBridge mod running.
- **File Watcher** enabled in Options, **Autosave off**.
- The script must already be open as a code window in the game (open `main.py` once manually; it stays open).

**Args:**
- `script_name` — name without `.py` (e.g. `"main"`).
- `content` — complete source code to write.
- `save_name` — save slot (default: `Save0`).
- `timeout_sec` — max seconds to wait (default: `120`).

**Returns:** same shape as `live_run_and_wait()`:
```json
{
  "output":      "harvested 5 hay\n",
  "state":       { "unlocks": {...}, "items": {...}, ... },
  "elapsed_sec": 4.2,
  "timed_out":   false
}
```

---

## MCP resources (read-only URI access)

| URI | Content |
|-----|---------|
| `tfwr://saves` | JSON list of save slot names |
| `tfwr://saves/{save}/state` | `read_game_state()` output as JSON |
| `tfwr://saves/{save}/scripts/{script}` | Raw source of a script file |

---

## Live tools — docs

These tools interact with the game's DocsWindow system (requires MCPBridge mod).

---

### `live_get_open_docs()`
Lists all DocsWindows currently open in the game UI.

**Returns:**
```json
{
  "docs": [
    {
      "window":  "docs0",
      "doc":     "unlocks/loops",
      "content": "# loops\n\nUnlocks **while** loops...\n"
    }
  ]
}
```
- `window` — pass to `live_close_docs_window()`.
- `doc` — the doc path loaded in that window (same format as `live_fetch_doc()`).
- `content` — full rendered markdown text.

---

### `live_close_docs_window(window_name)`
Closes a DocsWindow by its window name.

**Args:**
- `window_name` — from `live_get_open_docs()`, e.g. `"docs0"`.

**Returns:** `{"ok": true/false, "message"/"error": str}`

---

### `live_fetch_doc(doc_path)`
Fetches the text content of any game doc without opening a UI window.

**Supported path formats:**
| Prefix | Example | Source |
|--------|---------|--------|
| *(none / `docs/`)* | `"docs/home.md"` | Markdown file bundled with the game |
| `unlocks/` | `"unlocks/loops"` | Unlock tooltip text |
| `functions/` | `"functions/harvest"` | Function reference tooltip |
| `items/` | `"items/Hay"` | Item tooltip |
| `objects/` | `"objects/Wheat"` | Farm object tooltip |

**Args:**
- `doc_path` — doc path in any of the formats above.

**Returns:** `{"path": str, "content": str}`

---

## Persistent docs — scraped game documentation

Game docs are saved to disk at `<game_data>/docs/` and persist across sessions.
The `docs/` prefix is automatically stripped from paths to avoid double-nesting,
so `"docs/home.md"` and `"home.md"` both resolve to `<game_data>/docs/home.md`.

---

### `capture_upgrade_docs()`
**The primary tool for capturing upgrade documentation.**

Reads every open DocsWindow from the game, saves each doc to disk, then
closes all the windows. Call this immediately after `live_buy_upgrade()` —
the game opens a DocsWindow automatically when an upgrade is purchased.

**Returns:**
```json
{
  "captured": [
    { "doc": "unlocks/loops", "window": "docs0", "saved": true }
  ],
  "message": "Captured and saved 1/1 docs"
}
```

---

### `save_game_doc(doc_path, content)`
Saves arbitrary doc content to disk. Use when you have fetched content via
`live_fetch_doc()` and want to persist it for later reference.

**Args:**
- `doc_path` — game doc path (e.g. `"unlocks/loops"` or `"docs/home.md"`).
- `content` — markdown content to write.

**Returns:** `str` — confirmation with file path.

---

### `read_game_doc(doc_path)`
Reads a previously saved doc from disk. Raises if the file does not exist.

**Args:**
- `doc_path` — same format as `save_game_doc()`.

**Returns:** `str` — markdown content.

---

### `list_game_docs()`
Lists all saved game docs.

**Returns:** `list[str]` — paths relative to the `docs/` folder,
e.g. `["home.md", "unlocks/loops.md", "unlocks/variables.md"]`.

---

## Persistent notes & goals (per save slot)

Notes and goals are stored in the save slot directory alongside scripts:
- `<saves>/<SaveN>/notes.md` — free-form observations and discoveries
- `<saves>/<SaveN>/goals.md` — current goals and progress tracking

Both tools read/write the full file content on each call.

---

### `read_notes(save_name="Save0")`
Read persistent notes for a save slot.

**Returns:** `str` — markdown content, or empty string if none exist yet.

---

### `save_notes(content, save_name="Save0")`
Overwrite persistent notes for a save slot. Call this to record observations,
farming strategies, item unlock costs, or anything worth remembering.

**Args:**
- `content` — full markdown content.
- `save_name` — save slot (default: `Save0`).

**Returns:** `str` — confirmation.

---

### `read_goals(save_name="Save0")`
Read the current goals and progress for a save slot.

**Returns:** `str` — markdown content, or empty string if none exist yet.

---

### `save_goals(content, save_name="Save0")`
Overwrite goals and progress for a save slot. Update this whenever goals
change or milestones are reached.

**Args:**
- `content` — full markdown content.
- `save_name` — save slot (default: `Save0`).

**Returns:** `str` — confirmation.

---

## Mod HTTP endpoints (Plugin.cs)

The MCPBridge mod exposes these routes on `localhost:7070`.
The Python MCP server calls them internally; you should not need to call them directly.

| Method | Path | Description |
|--------|------|-------------|
| GET | `/api/status` | Execution + simulation flags, world size, elapsed time |
| GET | `/api/state` | Full state: unlocks, inventory, world size, execution flags |
| GET | `/api/output` | Accumulated `print()` output and warnings |
| DELETE | `/api/output` | Clear output log |
| GET | `/api/scripts` | Code windows open in the game UI |
| POST | `/api/run` | Start a named script `{"script": "main"}` |
| POST | `/api/stop` | Stop current execution |
| POST | `/api/step` | Advance one step (step-by-step mode) |
| GET | `/api/grid` | Full farm grid: every cell's entity, ground, water; drone positions |
| GET | `/api/shop` | All purchasable upgrades with costs and affordability |
| POST | `/api/buy` | Purchase an upgrade `{"unlock": "loops"}` |
| GET | `/api/docs` | All open DocsWindows with window name, doc path, and markdown content |
| POST | `/api/docs/close` | Close a DocsWindow by name `{"window": "docs0"}` |
| GET | `/api/docs/fetch` | Fetch any doc's text without opening a UI window `?path=docs/home.md` |

All responses are JSON. Error responses have `{"ok": false, "error": "..."}`.
Success responses have `{"ok": true, "message": "..."}` or the relevant data object.

---

## Tool decision guide

| Situation | Use |
|-----------|-----|
| First thing in a session | `live_snapshot()` → `live_farm_grid()` → `live_shop()` |
| Check persistent goals/notes | `read_goals()` → `read_notes()` |
| Need to know what functions exist | `get_builtins_reference()` |
| Write + run + get results | `live_write_run_wait()` |
| Script already written, just run it | `live_run_and_wait()` |
| Check if I can buy something | `live_shop()` |
| Purchase an upgrade | `live_buy_upgrade(name)` → `capture_upgrade_docs()` |
| Save upgrade doc after buying | `capture_upgrade_docs()` |
| Scrape a doc page on demand | `live_fetch_doc(path)` → `save_game_doc(path, content)` |
| Read a previously saved doc | `read_game_doc(path)` or `list_game_docs()` |
| Record an observation or insight | `save_notes(updated_content)` |
| Update goals / mark progress | `save_goals(updated_content)` |
| See what's on the farm | `live_farm_grid()` |
| Mod not running / early setup | `write_script()` + `read_game_state()` |
| Check if a script is still running | `live_status()` |
| Read script output after a run | `live_output()` (or check `"output"` in run results) |
